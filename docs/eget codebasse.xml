This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
home/
  home.go
man/
  eget.md
test/
  test_eget.go
tools/
  build-all.go
  build-version.go
.gitignore
archive.go
config.go
detect.go
dl.go
DOCS.md
eget.go
extract.go
find.go
flags.go
go.mod
LICENSE
Makefile
README.md
verify.go
version.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="home/home.go">
package home
⋮----
import (
	"fmt"
	"os/user"
	"path/filepath"
	"strings"
)
⋮----
"fmt"
"os/user"
"path/filepath"
"strings"
⋮----
func Home() (string, error)
⋮----
func Expand(path string) (string, error)
⋮----
var userData *user.User
var err error
</file>

<file path="man/eget.md">
---
title: eget
section: 1
header: Eget Manual
---

# NAME
  eget - easily install prebuilt binaries from GitHub

# SYNOPSIS
  eget `[--version] [--help] [OPTIONS] TARGET`

# DESCRIPTION
  Eget is a tool for downloading and extracting prebuilt binaries from releases
  on GitHub. To use it, provide a repository and Eget will search through the
  assets from the latest release in an attempt to find a suitable prebuilt
  binary for your system. If one is found, the asset will be downloaded and
  Eget will extract the binary to the current directory. Eget should only be
  used for installing simple, static prebuilt binaries, where the extracted
  binary is all that is needed for installation. For more complex installation,
  you may use the `--download-only` option, and perform extraction manually.

  The **`PROJECT`** argument passed to Eget should either be a GitHub
  repository, formatted as **`user/repo`**, in which case Eget will search the
  release assets, a direct URL, in which case Eget will directly download and
  extract from the given URL, or a local file, in which case Eget will extract
  directly from the local file.

  If Eget downloads an asset called `xxx` and there also exists an asset called
  `xxx.sha256` or `xxx.sha256sum`, Eget will automatically verify that the
  SHA-256 checksum of the downloaded asset matches the one contained in that
  file, and abort installation if a mismatch occurs.

  When installing an executable, Eget will place it in the current directory by
  default. If the environment variable **`EGET_BIN`** is non-empty, Eget will
  place the executable in that directory. The `--to` flag may also be used to
  customize the install location.

  Directories can also be specified as files to extract, and all files within
  them will be extracted. For example:

      eget https://go.dev/dl/go1.17.5.linux-amd64.tar.gz --file go --to ~/go1.17.5

  GitHub limits API requests to 60 per hour for unauthenticated users. If you
  would like to perform more requests (up to 5,000 per hour), you can set up a
  personal access token and assign it to an environment variable named either
  **`GITHUB_TOKEN`** or **`EGET_GITHUB_TOKEN`** when running Eget. If both are set,
  **`EGET_GITHUB_TOKEN`** will take precedence. Eget will read this variable and
  send the token as authorization with requests to GitHub. It is also possible to
  read the token from a file by using `@/path/to/file` as the token value.

  The behavior of Eget is configurable in a number of ways via options.
  Documentation for these options is provided below.

# OPTIONS
  `-t, --tag=`

:    Use the given tagged release instead of the latest release. If the project does not have a tag that matches exactly, eget will look for a tag that contains the given string, and use the latest one. Example: **`eget -t nightly zyedidia/micro`**.

  `--pre-release`

:    Include pre-releases when fetching the latest version. This will get the latest overall release, even if it is a pre-release.

  `--source`

:    Download the source code for the repository (only works for GitHub repositories) rather than a release. Downloads from the "master" branch by default. Use `--tag` to download a different tag or branch.

  `--to=`

:    Move the executable to the given name after extraction. If the name is `-`, it the data will be written to stdout. Example: **`eget zyedidia/micro --to /usr/local/bin`**. Example: **`eget --asset nvim.appimage --to nvim neovim/neovim`**.

  `-s, --system=`

:    Use the given system as the target instead of the host. Systems follow the notation 'OS/Arch', where OS is a valid OS (darwin, windows, linux, netbsd, openbsd, freebsd, android, illumos, solaris, plan9), and Arch is a valid architecture (amd64, 386, arm, arm64, riscv64). If the special value **all** is used, all possibilities are given and the user must select manually. Example: **`eget -s darwin/amd64 zyedidia/micro`**.

  `-f, --file=`

:    Extract the file that matches the given glob. You may want use this option to extract non-binary files. Example: **`eget -f LICENSE zyedidia/micro`**.

  `--all`

:    Extract all candidate files.

  `-q, --quiet`

:    Only print essential output.

  `--download-only`

:    Stop after downloading the asset. This prevents Eget from performing extraction, allowing you to perform manual installation after the asset is downloaded.

  `--download-all`

:   Download all projects defined in the configuration file.

   --upgrade-only

:    Only download the asset if the release is more recent than an existing asset with the same name in `$EGET_BIN`, or the current directory if `$EGET_BIN` is not defined.

  `-a, --asset=`

:    Download a specific asset containing the given string. If there is an exact match with an asset, that asset is used regardless (except when using `^`). If the argument begins with a `^`, then any asset that does not match the argument is a candidate. This option can be specified multiple times for additional filtering. Example: **`eget --asset nvim.appimage neovim/neovim`**. Example **`eget --download-only --asset amd64.deb --asset musl sharkdp/bat`**. If the assets are filterable using the `--system` detector (i.e., if applying the detector does not remove all candidates), the system detector is applied. Use `--system all` to always consider all assets.

  `--sha256`

:    Show the SHA-256 hash of the downloaded asset. This can be used to verify that the asset is not corrupted.

  `--verify-sha256=`

:    Verify the SHA-256 hash of the downloaded asset against the one provided as an argument. Similar to `--sha256`, but Eget will do the verification for you.

  `--rate`

:    Show GitHub API rate limiting information.

  `--remove`

:    Remove the target file from `$EGET_BIN` (or the current directory if unset). Note that this flag is boolean, and means eget will treat `TARGET` as a file to be removed.

  `-k, --disable-ssl`

:    Disable SSL certificate verification for GET requests. Cannot be used in combination with a `GITHUB_TOKEN`.

  `-v, --version`

:    Show version information.

  `-h, --help`

:    Show a help message.

# CONFIGURATION
  Eget can be configured using a TOML file located at `~/.eget.toml`. Alternatively,
  the configuration file can be located in the same directory as the Eget binary.

  Both global settings can be configured, as well as setting on a per-repository basis.

  Sections can be named either `global` or `"owner/repo"`, where `owner` and `repo`
  are the owner and repository name of the target repository (not that the `owner/repo` 
  format is quoted).

  For example, the following configuration file will set the `--to` flag to `~/bin` for 
  all repositories, and will set the `--to` flag to `~/.local/bin` for the `zyedidia/micro` 
  repository.

```toml
  [global]
  target = "~/bin"

  ["zyedidia/micro"]
  target = "~/.local/bin"
```

  More complete example configuration:

```toml
[global]
    github_token = "ghp_1234567890"
    quiet = false
    show_hash = false
    upgrade_only = true
    target = "./test"

["zyedidia/micro"]
    upgrade_only = false
    show_hash = true
    asset_filters = [ "static", ".tar.gz" ]
    target = "~/.local/bin/micro"
```

  By using the configuration above, you could run the following command to download
  the latest release of `micro`:
  **`eget zyedidia/micro`**

  Without the configuration, you would need to run the following command instead:
  **`eget zyedidia/micro --to ~/.local/bin/micro --sha256 --asset static --asset .tar.gz`**

## Available settings

  `all`

:    Whether to extract all candidate files.

  `asset_filters`

:    An array of partial asset names to filter the available assets for download.

  `download_only`

:    Whether to stop after downloading the asset (no extraction).

  `file`

:    The glob to select files for extraction.

  `github_token`
  
:    GitHub API token to use for requests.

  `quiet`

:    Whether to only print essential output.

  `show_hash`

:    Whether to show the SHA-256 hash of the downloaded asset.

  `system`

:    The target system to download for.

  `target`

:    The directory to move the downloaded file to after extraction.

  `upgrade_only`

:    Whether to only download if release is more recent than current version.

# FOR MAINTAINERS

To guarantee compatibility of your software's pre-built binaries with Eget, you
can follow these rules.

* Provide your pre-built binaries as GitHub release assets.
* Format the system name as `OS_Arch` and include it in every pre-built binary
  name. Supported OSes are `darwin`/`macos`, `windows`, `linux`, `netbsd`, `openbsd`,
  `freebsd`, `android`, `illumos`, `solaris`, `plan9`. Supported architectures
  are `amd64`, `i386`, `arm`, `arm64`, `riscv64`.
* If desired, include `*.sha256` files for each asset, containing the SHA-256
  checksum of each asset. These checksums will be automatically verified by
  Eget.
* Include only a single executable or appimage per system in each release archive.
* Use `.tar.gz`, `.tar.bz2`, `.tar.xz`, `.tar`, or `.zip` for archives. You may
  also directly upload the executable without an archive, or a compressed
  executable ending in `.gz`, `.bz2`, or `.xz`.

If you don't follow these rules, Eget may still work well with your software.
Eget's auto-detection is much more relaxed than what is required by these
rules, but if you follow these rules your software is guaranteed to be
compatible with Eget.

# BUGS

See GitHub Issues: <https://github.com/zyedidia/eget/issues>

# AUTHOR

Zachary Yedidia <zyedidia@gmail.com>
</file>

<file path="test/test_eget.go">
package main
⋮----
import (
	"fmt"
	"os"
	"os/exec"
)
⋮----
"fmt"
"os"
"os/exec"
⋮----
func fileExists(path string) error
⋮----
func run(name string, args ...string) error
⋮----
func must(err error)
⋮----
func main()
</file>

<file path="tools/build-all.go">
//go:build ignore
⋮----
package main
⋮----
import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"sync"
)
⋮----
"fmt"
"os"
"os/exec"
"runtime"
"sync"
⋮----
type Target struct {
	OS   string
	Arch string
}
⋮----
func main()
⋮----
var wg sync.WaitGroup
</file>

<file path="tools/build-version.go">
package main
⋮----
import (
	"fmt"
	"os/exec"
	"strings"

	"github.com/blang/semver"
)
⋮----
"fmt"
"os/exec"
"strings"
⋮----
"github.com/blang/semver"
⋮----
func getTag(match ...string) (string, *semver.PRVersion)
⋮----
func main()
</file>

<file path=".gitignore">
eget
eget.exe
eget-*
todo.txt
eget.1
/test/*
!/test/test_eget.go
!/test/eget.toml
.eget.toml
</file>

<file path="archive.go">
package main
⋮----
import (
	"archive/tar"
	"archive/zip"
	"bytes"
	"fmt"
	"io"
	"io/fs"
	"strings"
)
⋮----
"archive/tar"
"archive/zip"
"bytes"
"fmt"
"io"
"io/fs"
"strings"
⋮----
type FileType byte
⋮----
const (
	TypeNormal FileType = iota
	TypeDir
	TypeLink
	TypeSymlink
	TypeOther
)
⋮----
func tarft(typ byte) FileType
⋮----
type File struct {
	Name     string
	LinkName string
	Mode     fs.FileMode
	Type     FileType
}
⋮----
func (f File) Dir() bool
⋮----
type Archive interface {
	Next() (File, error)
	ReadAll() ([]byte, error)
}
⋮----
type TarArchive struct {
	r *tar.Reader
}
⋮----
func NewTarArchive(data []byte, decompress DecompFn) (Archive, error)
⋮----
func (t *TarArchive) Next() (File, error)
⋮----
func (t *TarArchive) ReadAll() ([]byte, error)
⋮----
type ZipArchive struct {
	r   *zip.Reader
	idx int
}
⋮----
func NewZipArchive(data []byte, d DecompFn) (Archive, error)
</file>

<file path="config.go">
package main
⋮----
import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"runtime"

	"github.com/BurntSushi/toml"
	"github.com/jessevdk/go-flags"
	"github.com/zyedidia/eget/home"
)
⋮----
"errors"
"fmt"
"os"
"path/filepath"
"runtime"
⋮----
"github.com/BurntSushi/toml"
"github.com/jessevdk/go-flags"
"github.com/zyedidia/eget/home"
⋮----
type ConfigGlobal struct {
	All          bool   `toml:"all"`
	DownloadOnly bool   `toml:"download_only"`
	File         string `toml:"file"`
	GithubToken  string `toml:"github_token"`
	Quiet        bool   `toml:"quiet"`
	ShowHash     bool   `toml:"show_hash"`
	Source       bool   `toml:"download_source"`
	System       string `toml:"system"`
	Target       string `toml:"target"`
	UpgradeOnly  bool   `toml:"upgrade_only"`
}
⋮----
type ConfigRepository struct {
	All          bool     `toml:"all"`
	AssetFilters []string `toml:"asset_filters"`
	DownloadOnly bool     `toml:"download_only"`
	File         string   `toml:"file"`
	Name         string   `toml:"name"`
	Quiet        bool     `toml:"quiet"`
	ShowHash     bool     `toml:"show_hash"`
	Source       bool     `toml:"download_source"`
	System       string   `toml:"system"`
	Tag          string   `toml:"tag"`
	Target       string   `toml:"target"`
	UpgradeOnly  bool     `toml:"upgrade_only"`
	Verify       string   `toml:"verify_sha256"`
	DisableSSL   bool     `toml:"disable_ssl"`
}
⋮----
type Config struct {
	Meta struct {
		Keys     []string
		MetaData *toml.MetaData
	}
⋮----
func LoadConfigurationFile(path string) (Config, error)
⋮----
var conf Config
⋮----
func GetOSConfigPath(homePath string) string
⋮----
var configDir string
⋮----
var goos string
⋮----
func InitializeConfig() (*Config, error)
⋮----
var err error
var config Config
⋮----
func update[T any](config T, cli *T) T
⋮----
func SetGlobalOptionsFromConfig(config *Config, parser *flags.Parser, opts *Flags, cli CliFlags) error
⋮----
func SetProjectOptionsFromConfig(config *Config, parser *flags.Parser, opts *Flags, cli CliFlags, projectName string) error
</file>

<file path="detect.go">
package main
⋮----
import (
	"fmt"
	"path"
	"regexp"
	"strings"
)
⋮----
"fmt"
"path"
"regexp"
"strings"
⋮----
type Detector interface {



	Detect(assets []string) (string, []string, error)
}
⋮----
type DetectorChain struct {
	detectors []Detector
	system    Detector
}
⋮----
func (dc *DetectorChain) Detect(assets []string) (string, []string, error)
⋮----
type OS struct {
	name     string
	regex    *regexp.Regexp
	anti     *regexp.Regexp
	priority *regexp.Regexp
}
⋮----
func (os *OS) Match(s string) (bool, bool)
⋮----
var (
	OSDarwin = OS{
		name:  "darwin",
		regex: regexp.MustCompile(`(?i)(darwin|mac.?(os)?|osx)`),
⋮----
var goosmap = map[string]OS{
	"darwin":  OSDarwin,
	"windows": OSWindows,
	"linux":   OSLinux,
	"netbsd":  OSNetBSD,
	"openbsd": OSOpenBSD,
	"freebsd": OSFreeBSD,
	"android": OSAndroid,
	"illumos": OSIllumos,
	"solaris": OSSolaris,
	"plan9":   OSPlan9,
}
⋮----
type Arch struct {
	name  string
	regex *regexp.Regexp
}
⋮----
var (
	ArchAMD64 = Arch{
		name:  "amd64",
		regex: regexp.MustCompile(`(?i)(x64|amd64|x86(-|_)?64)`),
⋮----
var goarchmap = map[string]Arch{
	"amd64":   ArchAMD64,
	"386":     ArchI386,
	"arm":     ArchArm,
	"arm64":   ArchArm64,
	"riscv64": ArchRiscv64,
}
⋮----
type AllDetector struct{}
⋮----
type SingleAssetDetector struct {
	Asset string
	Anti  bool
}
⋮----
var candidates []string
⋮----
type SystemDetector struct {
	Os   OS
	Arch Arch
}
⋮----
func NewSystemDetector(sos, sarch string) (*SystemDetector, error)
⋮----
var priority []string
var matches []string
</file>

<file path="dl.go">
package main
⋮----
import (
	"crypto/tls"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	pb "github.com/schollz/progressbar/v3"
	"github.com/zyedidia/eget/home"
)
⋮----
"crypto/tls"
"encoding/json"
"errors"
"fmt"
"io"
"net/http"
"os"
"strings"
"time"
⋮----
pb "github.com/schollz/progressbar/v3"
"github.com/zyedidia/eget/home"
⋮----
func tokenFrom(s string) (string, error)
⋮----
var ErrNoToken = errors.New("no github token")
⋮----
func getGithubToken() (string, error)
⋮----
func SetAuthHeader(req *http.Request) *http.Request
⋮----
func Get(url string) (*http.Response, error)
⋮----
type RateLimitJson struct {
	Resources map[string]RateLimit
}
⋮----
type RateLimit struct {
	Limit     int
	Remaining int
	Reset     int64
}
⋮----
func (r RateLimit) ResetTime() time.Time
⋮----
func (r RateLimit) String() string
⋮----
func GetRateLimit() (RateLimit, error)
⋮----
var parsed RateLimitJson
⋮----
func Download(url string, out io.Writer, getbar func(size int64) *pb.ProgressBar) error
</file>

<file path="DOCS.md">
# Eget Documentation

Eget works in four phases:

* Find: determine a list of assets that may be installed.
* Detect: determine which asset in the list should be downloaded for the target system.
* Verify: verify the checksum of the asset if possible.
* Extract: determine which file within the asset to extract.

If you are interested in reading the source code, there is one file for each
phase, and the `eget.go` main file runs a routine that combines them all
together.

## Find

If the input is a repo identifier, the Find phase queries `api.github.com` with
the repo and reads the list of assets from the response JSON. If a direct URL
is provided, the Find phase just returns the direct URL without doing any work.

## Detect

The Detect phase attempts to determine what OS and architecture each asset is
built for. This is done by matching a regular expression for each
OS/architecture that Eget knows about. The match rules are shown below, and are
case insensitive.

| OS            | Match Rule           |
| ------------- | -------------------- |
| `darwin`      | `darwin\|mac.?os\|osx` |
| `windows`     | `win\|windows`        |
| `linux`       | `linux`              |
| `netbsd`      | `netbsd`             |
| `openbsd`     | `openbsd`            |
| `freebsd`     | `freebsd`            |
| `android`     | `android`            |
| `illumos`     | `illumos`            |
| `solaris`     | `solaris`            |
| `plan9`       | `plan9`              |

| Architecture  | Match Rule                    |
| ------------- | ----------------------------- |
| `amd64`       | `x64\|amd64\|x86(-\|_)?64`       |
| `386`         | `x32\|amd32\|x86(-\|_)?32\|i?386` |
| `arm`         | `arm`                         |
| `arm64`       | `arm64\|armv8\|aarch64`                 |
| `riscv64`     | `riscv64`                     |

If you would like a new OS/Architecture to be added, or find a case where the
auto-detection is not adequate (within reason), please open an issue.

Using the direct OS/Architecture (left column of the above tables) name in your
prebuilt zip file names will always allow Eget to auto-detect correctly,
although Eget will often auto-detect correctly for other names as well.

## Verify

During verification, Eget will attempt to verify the checksum of the downloaded
asset. If the user has provided a checksum, or asked Eget to simply print the
checksum, it will do so. Otherwise it may do auto-detection. If it is
downloading an asset called `xxx`, and there is another asset called
`xxx.sha256` or `xxx.sha256sum`, Eget will automatically verify the SHA-256
checksum of the downloaded asset against the one contained in the
`.sha256`/`.sha256sum` file.

## Extract

During extraction, Eget will detect the type of archive and compression, and
use this information to extract the requested file. If there is no requested
file, Eget will extract a file with executable permissions, with priority given
to files that have the same name as the repo. If multiple files with executable
permissions exist and none of them match the repo name, Eget will ask the user
to choose. Files ending in `.exe` are also assumed to be executable, regardless
of permissions within the archive.

Eget supports the following filetypes for assets:

* `.tar.gz`/`.tgz`: tar archive with gzip compression.
* `.tar.bz2`: tar archive with bzip2 compression.
* `.tar.xz`: tar archive with xz compression.
* `.tar`: tar archive with no compression.
* `.zip`: zip archive.
* `.gz`: single file with gzip compression.
* `.bz2`: single file with bzip2 compression.
* `.xz`: single file with xz compression.
* otherwise: single file.

If a single file is "extracted" (no tar or zip archive), it will be marked
executable automatically.
</file>

<file path="eget.go">
package main
⋮----
import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/jessevdk/go-flags"
	pb "github.com/schollz/progressbar/v3"
)
⋮----
"bytes"
"errors"
"fmt"
"io"
"io/fs"
"net/url"
"os"
"os/exec"
"path"
"path/filepath"
"regexp"
"runtime"
"strings"
"time"
⋮----
"github.com/jessevdk/go-flags"
pb "github.com/schollz/progressbar/v3"
⋮----
func fatal(a ...interface
⋮----
func IsUrl(s string) bool
⋮----
func Cut(s, sep string) (before, after string, found bool)
⋮----
var ghrgx = regexp.MustCompile(`^(http(s)?://)?github\.com/[\w,\-,_]+/[\w,\-,_]+(.git)?(/)?$`)
⋮----
func IsGithubUrl(s string) bool
⋮----
func IsLocalFile(s string) bool
⋮----
func IsDirectory(path string) bool
⋮----
func checksumAsset(asset string, assets []string) string
⋮----
func getFinder(project string, opts *Flags) (finder Finder, tool string)
⋮----
var mint time.Time
⋮----
func getVerifier(sumAsset string, opts *Flags) (verifier Verifier, err error)
⋮----
func getDetector(opts *Flags) (detector Detector, err error)
⋮----
var system Detector
⋮----
func getExtractor(url, tool string, opts *Flags) (extractor Extractor, err error)
⋮----
func writeFile(data []byte, rename string, mode fs.FileMode) error
⋮----
func userSelect(choices []interface
⋮----
var choice int
⋮----
func bintime(bin string, to string) (t time.Time)
⋮----
func downloadConfigRepositories(config *Config) error
⋮----
var opts Flags
⋮----
func main()
⋮----
var cli CliFlags
⋮----
var output io.Writer = os.Stderr
⋮----
var pbout io.Writer = os.Stderr
</file>

<file path="extract.go">
package main
⋮----
import (
	"bufio"
	"bytes"
	"compress/bzip2"
	"compress/gzip"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"github.com/gobwas/glob"
	"github.com/klauspost/compress/zstd"
	"github.com/ulikunitz/xz"
)
⋮----
"bufio"
"bytes"
"compress/bzip2"
"compress/gzip"
"fmt"
"io"
"io/fs"
"os"
"path/filepath"
"strings"
⋮----
"github.com/gobwas/glob"
"github.com/klauspost/compress/zstd"
"github.com/ulikunitz/xz"
⋮----
type Extractor interface {
	Extract(data []byte, multiple bool) (ExtractedFile, []ExtractedFile, error)
}
⋮----
type ExtractedFile struct {
	Name        string
	ArchiveName string
	mode        fs.FileMode
	Extract     func(to string) error
	Dir         bool
}
⋮----
func (e ExtractedFile) Mode() fs.FileMode
⋮----
func modeFrom(fname string, mode fs.FileMode) fs.FileMode
⋮----
func (e ExtractedFile) String() string
⋮----
type Chooser interface {
	Choose(name string, dir bool, mode fs.FileMode) (direct bool, possible bool)
}
⋮----
func NewExtractor(filename string, tool string, chooser Chooser) Extractor
⋮----
type ArchiveFn func(data []byte, decomp DecompFn) (Archive, error)
type DecompFn func(r io.Reader) (io.Reader, error)
⋮----
type ArchiveExtractor struct {
	File       Chooser
	Ar         ArchiveFn
	Decompress DecompFn
}
⋮----
type link struct {
	newname string
	oldname string
	sym     bool
}
⋮----
func (l link) Write() error
⋮----
func (a *ArchiveExtractor) Extract(data []byte, multiple bool) (ExtractedFile, []ExtractedFile, error)
⋮----
var candidates []ExtractedFile
var dirs []string
⋮----
var hasdir bool
⋮----
var extract func(to string) error
⋮----
var links []link
⋮----
type SingleFileExtractor struct {
	Rename     string
	Name       string
	Decompress func(r io.Reader) (io.Reader, error)
}
⋮----
func rename(file string, nameguess string) string
⋮----
var rename string
⋮----
type BinaryChooser struct {
	Tool string
}
⋮----
func (b *BinaryChooser) Choose(name string, dir bool, mode fs.FileMode) (bool, bool)
⋮----
func isDefinitelyNotExec(file string) bool
⋮----
func isExec(file string, mode os.FileMode) bool
⋮----
type LiteralFileChooser struct {
	File string
}
⋮----
type GlobChooser struct {
	expr string
	g    glob.Glob
	all  bool
}
⋮----
func NewGlobChooser(gl string) (*GlobChooser, error)
</file>

<file path="find.go">
package main
⋮----
import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)
⋮----
"encoding/json"
"errors"
"fmt"
"io"
"net/http"
"strings"
"time"
⋮----
type Finder interface {
	Find() ([]string, error)
}
⋮----
type GithubRelease struct {
	Assets []struct {
		DownloadURL string `json:"browser_download_url"`
	} `json:"assets"`
⋮----
type GithubError struct {
	Code   int
	Status string
	Body   []byte
	Url    string
}
type errResponse struct {
	Message string `json:"message"`
	Doc     string `json:"documentation_url"`
}
⋮----
func (ge *GithubError) Error() string
⋮----
var msg errResponse
⋮----
type GithubAssetFinder struct {
	Repo       string
	Tag        string
	Prerelease bool
	MinTime    time.Time
}
⋮----
var ErrNoUpgrade = errors.New("requested release is not more recent than current version")
⋮----
func (f *GithubAssetFinder) Find() ([]string, error)
⋮----
var release GithubRelease
⋮----
func (f *GithubAssetFinder) FindMatch() ([]string, error)
⋮----
var releases []GithubRelease
⋮----
func (f *GithubAssetFinder) getLatestTag() (string, error)
⋮----
var releases []GithubRelease
⋮----
type DirectAssetFinder struct {
	URL string
}
⋮----
type GithubSourceFinder struct {
	Tool string
	Repo string
	Tag  string
}
</file>

<file path="flags.go">
package main
⋮----
type Flags struct {
	Tag         string
	Prerelease  bool
	Source      bool
	Output      string
	System      string
	ExtractFile string
	All         bool
	Quiet       bool
	DLOnly      bool
	UpgradeOnly bool
	Asset       []string
	Hash        bool
	Verify      string
	Remove      bool
	DisableSSL  bool
}
⋮----
type CliFlags struct {
	Tag         *string   `short:"t" long:"tag" description:"tagged release to use instead of latest"`
	Prerelease  *bool     `long:"pre-release" description:"include pre-releases when fetching the latest version"`
	Source      *bool     `long:"source" description:"download the source code for the target repo instead of a release"`
	Output      *string   `long:"to" description:"move to given location after extracting"`
	System      *string   `short:"s" long:"system" description:"target system to download for (use \"all\" for all choices)"`
	ExtractFile *string   `short:"f" long:"file" description:"glob to select files for extraction"`
	All         *bool     `long:"all" description:"extract all candidate files"`
	Quiet       *bool     `short:"q" long:"quiet" description:"only print essential output"`
	DLOnly      *bool     `short:"d" long:"download-only" description:"stop after downloading the asset (no extraction)"`
	UpgradeOnly *bool     `long:"upgrade-only" description:"only download if release is more recent than current version"`
	Asset       *[]string `short:"a" long:"asset" description:"download a specific asset containing the given string; can be specified multiple times for additional filtering; use ^ for anti-match"`
	Hash        *bool     `long:"sha256" description:"show the SHA-256 hash of the downloaded asset"`
	Verify      *string   `long:"verify-sha256" description:"verify the downloaded asset checksum against the one provided"`
	Rate        bool      `long:"rate" description:"show GitHub API rate limiting information"`
	Remove      *bool     `short:"r" long:"remove" description:"remove the given file from $EGET_BIN or the current directory"`
	Version     bool      `short:"v" long:"version" description:"show version information"`
	Help        bool      `short:"h" long:"help" description:"show this help message"`
	DownloadAll bool      `short:"D" long:"download-all" description:"download all projects defined in the config file"`
	DisableSSL  *bool     `short:"k" long:"disable-ssl" description:"disable SSL verification for download requests"`
}
</file>

<file path="go.mod">
module github.com/zyedidia/eget

go 1.18

require (
	github.com/BurntSushi/toml v1.2.1
	github.com/blang/semver v3.5.1+incompatible
	github.com/gobwas/glob v0.2.3
	github.com/jessevdk/go-flags v1.5.0
	github.com/schollz/progressbar/v3 v3.8.2
	github.com/ulikunitz/xz v0.5.10
)

require (
	github.com/klauspost/compress v1.15.15 // indirect
	github.com/mattn/go-runewidth v0.0.13 // indirect
	github.com/mitchellh/colorstring v0.0.0-20190213212951-d06e56a500db // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	github.com/stretchr/testify v1.8.0 // indirect
	golang.org/x/crypto v0.0.0-20220411220226-7b82a4e95df4 // indirect
	golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a // indirect
	golang.org/x/term v0.0.0-20210927222741-03fcf44c2211 // indirect
)
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2021: Zachary Yedidia.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="Makefile">
VERSION = $(shell GOOS=$(shell go env GOHOSTOS) GOARCH=$(shell go env GOHOSTARCH) \
	go run tools/build-version.go)
SYSTEM = ${GOOS}_${GOARCH}
GOVARS = -X main.Version=$(VERSION)

build:
	go build -trimpath -ldflags "-s -w $(GOVARS)" .

build-dist:
	go build -trimpath -ldflags "-s -w $(GOVARS)" -o dist/bin/eget-$(VERSION)-$(SYSTEM) .

install:
	go install -trimpath -ldflags "-s -w $(GOVARS)" .

fmt:
	gofmt -s -w .

vet:
	go vet

eget:
	go build -trimpath -ldflags "-s -w $(GOVARS)" .

test: eget
	cd test; EGET_CONFIG=eget.toml EGET_BIN= TEST_EGET=../eget go run test_eget.go

eget.1: man/eget.md
	pandoc man/eget.md -s -t man -o eget.1

package: build-dist eget.1
	mkdir -p dist/eget-$(VERSION)-$(SYSTEM)
	cp README.md dist/eget-$(VERSION)-$(SYSTEM)
	cp LICENSE dist/eget-$(VERSION)-$(SYSTEM)
	cp eget.1 dist/eget-$(VERSION)-$(SYSTEM)
	if [ "${GOOS}" = "windows" ]; then\
		cp dist/bin/eget-$(VERSION)-$(SYSTEM) dist/eget-$(VERSION)-$(SYSTEM)/eget.exe;\
		cd dist;\
		zip -r -q -T eget-$(VERSION)-$(SYSTEM).zip eget-$(VERSION)-$(SYSTEM);\
	else\
		cp dist/bin/eget-$(VERSION)-$(SYSTEM) dist/eget-$(VERSION)-$(SYSTEM)/eget;\
		cd dist;\
		tar -czf eget-$(VERSION)-$(SYSTEM).tar.gz eget-$(VERSION)-$(SYSTEM);\
	fi

version:
	echo "package main\n\nvar Version = \"$(VERSION)+src\"" > version.go

clean:
	rm -f test/eget.1 test/fd test/micro test/nvim test/pandoc test/rg.exe
	rm -rf dist

.PHONY: build clean install package version fmt vet test
</file>

<file path="README.md">
# Eget: easy pre-built binary installation

[![Go Report Card](https://goreportcard.com/badge/github.com/zyedidia/eget)](https://goreportcard.com/report/github.com/zyedidia/eget)
[![Release](https://img.shields.io/github/release/zyedidia/eget.svg?label=Release)](https://github.com/zyedidia/eget/releases)
[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/zyedidia/eget/blob/master/LICENSE)

**Eget** is the best way to easily get pre-built binaries for your favorite
tools. It downloads and extracts pre-built binaries from releases on GitHub. To
use it, provide a repository and Eget will search through the assets from the
latest release in an attempt to find a suitable prebuilt binary for your
system. If one is found, the asset will be downloaded and Eget will extract the
binary to the current directory. Eget should only be used for installing
simple, static prebuilt binaries, where the extracted binary is all that is
needed for installation. For more complex installation, you may use the
`--download-only` option, and perform extraction manually.

![Eget Demo](https://github.com/zyedidia/blobs/blob/master/eget-demo.gif)

For software maintainers, if you provide prebuilt binaries on GitHub, you can
list `eget` as a one-line method for users to install your software.

Eget has a number of detection mechanisms and should work out-of-the-box with
most software that is distributed via single binaries on GitHub releases. First
try using Eget on your software, it may already just work. Otherwise, see the
FAQ for a clear set of rules to make your software compatible with Eget.

For more in-depth documentation, see [DOCS.md](DOCS.md).

# Examples

```
eget zyedidia/micro --tag nightly
eget jgm/pandoc --to /usr/local/bin
eget junegunn/fzf
eget neovim/neovim
eget ogham/exa --asset ^musl
eget --system darwin/amd64 sharkdp/fd
eget BurntSushi/ripgrep
eget -f eget.1 zyedidia/eget
eget zachjs/sv2v
eget https://go.dev/dl/go1.17.5.linux-amd64.tar.gz --file go --to ~/go1.17.5
eget --all --file '*' ActivityWatch/activitywatch
```

# How to get Eget

Before you can get anything, you have to get Eget. If you already have Eget and want to upgrade, use `eget zyedidia/eget`.

### Quick-install script

```
curl -o eget.sh https://zyedidia.github.io/eget.sh
shasum -a 256 eget.sh # verify with hash below
bash eget.sh
```

Or alternatively (less secure):

```
curl https://zyedidia.github.io/eget.sh | sh
```

You can then place the downloaded binary in a location on your `$PATH` such as `/usr/local/bin`.

To verify the script, the sha256 checksum is `0e64b8a3c13f531da005096cc364ac77835bda54276fedef6c62f3dbdc1ee919` (use `shasum -a 256 eget.sh` after downloading the script).

One of the reasons to use eget is to avoid running curl into bash, but unfortunately you can't eget eget until you have eget.

### Homebrew

```
brew install eget
```

### Chocolatey

```
choco install eget
```

### Pre-built binaries

Pre-built binaries are available on the [releases](https://github.com/zyedidia/eget/releases) page.

### From source

Install the latest released version:

```
go install github.com/zyedidia/eget@latest
```

or install from HEAD:

```
git clone https://github.com/zyedidia/eget
cd eget
make build # or go build (produces incomplete version information)
```

A man page can be generated by cloning the repository and running `make eget.1`
(requires pandoc). You can also use `eget` to download the man page: `eget -f eget.1 zyedidia/eget`.

# Usage

The `TARGET` argument passed to Eget should either be a GitHub repository,
formatted as `user/repo`, in which case Eget will search the release assets, a
direct URL, in which case Eget will directly download and extract from the
given URL, or a local file, in which case Eget will extract directly from the
local file.

If Eget downloads an asset called `xxx` and there also exists an asset called
`xxx.sha256` or `xxx.sha256sum`, Eget will automatically verify that the
SHA-256 checksum of the downloaded asset matches the one contained in that
file, and abort installation if a mismatch occurs.

When installing an executable, Eget will place it in the current directory by
default. If the environment variable `EGET_BIN` is non-empty, Eget will
place the executable in that directory.

Directories can also be specified as files to extract, and all files within
them will be extracted. For example:

```
eget https://go.dev/dl/go1.17.5.linux-amd64.tar.gz --file go --to ~/go1.17.5
```

GitHub limits API requests to 60 per hour for unauthenticated users. If you
would like to perform more requests (up to 5,000 per hour), you can set up a
personal access token and assign it to an environment variable named either
`GITHUB_TOKEN` or `EGET_GITHUB_TOKEN` when running Eget. If both are set,
`EGET_GITHUB_TOKEN` will take precedence. Eget will read this variable and
send the token as authorization with requests to GitHub. It is also possible
to read the token from a file by using `@/path/to/file` as the token value.

```
Usage:
  eget [OPTIONS] TARGET

Application Options:
  -t, --tag=           tagged release to use instead of latest
      --pre-release    include pre-releases when fetching the latest version
      --source         download the source code for the target repo instead of a release
      --to=            move to given location after extracting
  -s, --system=        target system to download for (use "all" for all choices)
  -f, --file=          glob to select files for extraction
      --all            extract all candidate files
  -q, --quiet          only print essential output
  -d, --download-only  stop after downloading the asset (no extraction)
      --upgrade-only   only download if release is more recent than current version
  -a, --asset=         download a specific asset containing the given string; can be specified multiple times for additional filtering; use ^ for anti-match
      --sha256         show the SHA-256 hash of the downloaded asset
      --verify-sha256= verify the downloaded asset checksum against the one provided
      --rate           show GitHub API rate limiting information
  -r, --remove         remove the given file from $EGET_BIN or the current directory
  -v, --version        show version information
  -h, --help           show this help message
  -D, --download-all   download all projects defined in the config file
  -k, --disable-ssl    disable SSL verification for download
```

# Configuration

Eget can be configured using a TOML file located at `~/.eget.toml` or it will fallback to the expected `XDG_CONFIG_HOME` directory of your os. Alternatively,
the configuration file can be located in the same directory as the Eget binary or the path specified with the environment variable `EGET_CONFIG`.

Both global settings can be configured, as well as setting on a per-repository basis.

Sections can be named either `global` or `"owner/repo"`, where `owner` and `repo`
are the owner and repository name of the target repository (not that the `owner/repo`
format is quoted).

For example, the following configuration file will set the `--to` flag to `~/bin` for
all repositories, and will set the `--to` flag to `~/.local/bin` for the `zyedidia/micro`
repository.

```toml
[global]
target = "~/bin"

["zyedidia/micro"]
target = "~/.local/bin"
```

## Available settings - global section

| Setting | Related Flag | Description | Default |
| --- | --- | --- | --- |
| `github_token` | `N/A` | GitHub API token to use for requests | `""` |
| `all` | `--all` | Whether to extract all candidate files. | `false` |
| `download_only` | `--download-only` | Whether to stop after downloading the asset (no extraction). | `false` |
| `download_source` | `--source` | Whether to download the source code for the target repo instead of a release. | `false` |
| `file` | `--file` | The glob to select files for extraction. | `*` |
| `quiet` | `--quiet` | Whether to only print essential output. | `false` |
| `show_hash` | `--sha256` | Whether to show the SHA-256 hash of the downloaded asset. | `false` |
| `system` | `--system` | The target system to download for. | `all` |
| `target` | `--to` | The directory to move the downloaded file to after extraction. | `.` |
| `upgrade_only` | `--upgrade-only` | Whether to only download if release is more recent than current version. | `false` |

## Available settings - repository sections

| Setting | Related Flag | Description | Default |
| --- | --- | --- | --- |
| `all` | `--all` | Whether to extract all candidate files. | `false` |
| `asset_filters` | `--asset` |  An array of partial asset names to filter the available assets for download. | `[]` |
| `download_only` | `--download-only` | Whether to stop after downloading the asset (no extraction). | `false` |
| `download_source` | `--source` | Whether to download the source code for the target repo instead of a release. | `false` |
| `file` | `--file` | The glob to select files for extraction. | `*` |
| `quiet` | `--quiet` | Whether to only print essential output. | `false` |
| `show_hash` | `--sha256` | Whether to show the SHA-256 hash of the downloaded asset. | `false` |
| `system` | `--system` | The target system to download for. | `all` |
| `target` | `--to` | The directory to move the downloaded file to after extraction. | `.` |
| `upgrade_only` | `--upgrade-only` | Whether to only download if release is more recent than current version. | `false` |
| `verify_sha256` | `--verify-sha256` | Verify the sha256 hash of the asset against a provided hash. | `""` |


## Example configuration

```toml
[global]
    github_token = "ghp_1234567890"
    quiet = false
    show_hash = false
    upgrade_only = true
    target = "./test"

["zyedidia/micro"]
    upgrade_only = false
    show_hash = true
    asset_filters = [ "static", ".tar.gz" ]
    target = "~/.local/bin/micro"
```

By using the configuration above, you could run the following command to download the latest release of `micro`:

```bash
eget zyedidia/micro
```

Without the configuration, you would need to run the following command instead:

```bash
export EGET_GITHUB_TOKEN=ghp_1234567890 &&\
eget zyedidia/micro --to ~/.local/bin/micro --sha256 --asset static --asset .tar.gz
```

# FAQ

### How is this different from a package manager?

Eget only downloads pre-built binaries uploaded to GitHub by the developers of
the repository. It does not maintain a central list of packages, nor does it do
any dependency management. Eget does not "install" executables by placing them
in system-wide directories (such as `/usr/local/bin`) unless instructed, and it
does not maintain a registry for uninstallation. Eget works best for installing
software that comes as a single binary with no additional files needed (CLI
tools made in Go, Rust, or Haskell tend to fit this description).

### Does Eget keep track of installed binaries?

Eget does not maintain any sort of manifest containing information about
installed binaries. In general, Eget does not maintain any state across
invocations. However, Eget does support the `--upgrade-only` option, which
will first check `EGET_BIN` to determine if you have already downloaded the
tool you are trying to install -- if so it will only download a new version if
the GitHub release is newer than the binary on your file system.

### Is this secure?

Eget does not run any downloaded code -- it just finds executables from GitHub
releases and downloads/extracts them. If you trust the code you are downloading
(i.e. if you trust downloading pre-built binaries from GitHub) then using Eget
is perfectly safe. If Eget finds a matching asset ending in `.sha256` or
`.sha256sum`, the SHA-256 checksum of your download will be automatically
verified. You can also use the `--sha256` or `--verify-sha256` options to
manually verify the SHA-256 checksums of your downloads (checksums are provided
in an alternative manner by your download source).

### Does this work only for GitHub repositories?

At the moment Eget supports searching GitHub releases, direct URLs, and local
files. If you provide a direct URL instead of a GitHub repository, Eget will
skip the detection phase and download directly from the given URL. If you
provide a local file, Eget will skip detection and download and just perform
extraction from the local file.

### How can I make my software compatible with Eget?

Eget should work out-of-the-box with many methods for releasing software, and
does not require that you build your release process for Eget in particular.
However, here are some rules that will guarantee compatibility with Eget.

- Provide your pre-built binaries as GitHub release assets.
- Format the system name as `OS_Arch` and include it in every pre-built binary
  name. Supported OSes are `darwin`/`macos`, `windows`, `linux`, `netbsd`,
  `openbsd`, `freebsd`, `android`, `illumos`, `solaris`, `plan9`. Supported
  architectures are `amd64`, `i386`, `arm`, `arm64`, `riscv64`.
- If desired, include `*.sha256` files for each asset, containing the SHA-256
  checksum of each asset. These checksums will be automatically verified by
  Eget.
- Include only a single executable or appimage per system in each release archive.
- Use `.tar.gz`, `.tar.bz2`, `.tar.xz`, `.tar`, or `.zip` for archives. You may
  also directly upload the executable without an archive, or a compressed
  executable ending in `.gz`, `.bz2`, or `.xz`.

### Does this work with monorepos?

Yes, you can pass a tag or tag identifier with the `--tag TAG` option. If no
tag exactly matches, Eget will look for the latest release with a tag that
contains `TAG`. So if your repository contains releases for multiple different
projects, just pass the appropriate tag (for the project you want) to Eget, and
it will find the latest release for that particular project (as long as
releases for that project are given tags that contain the project name).

# Contributing

If you find a bug, have a suggestion, or something else, please open an issue
for discussion. I am sometimes prone to leaving pull requests unmerged, so
please double check with me before investing lots of time into implementing a
pull request. See [DOCS.md](DOCS.md) for more in-depth documentation.
</file>

<file path="verify.go">
package main
⋮----
import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
)
⋮----
"bytes"
"crypto/sha256"
"encoding/hex"
"fmt"
"io"
⋮----
type Verifier interface {
	Verify(b []byte) error
}
⋮----
type NoVerifier struct{}
⋮----
func (n *NoVerifier) Verify(b []byte) error
⋮----
type Sha256Error struct {
	Expected []byte
	Got      []byte
}
⋮----
func (e *Sha256Error) Error() string
⋮----
type Sha256Verifier struct {
	Expected []byte
}
⋮----
func NewSha256Verifier(expectedHex string) (*Sha256Verifier, error)
⋮----
type Sha256Printer struct{}
⋮----
type Sha256AssetVerifier struct {
	AssetURL string
}
</file>

<file path="version.go">
package main
⋮----
var Version = "1.3.4+src"
</file>

</files>
